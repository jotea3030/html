<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Wingspan Bird Song Game</title>
    <style>
        /* ... (omitted unchanged CSS for brevity in this block) ... */
        /* keep the same CSS you already had, including .debug-log styling */
    </style>
</head>
<body>
    <div class="game-container">
        <div class="header">
            <h1>🦅 Wingspan Bird Song Game</h1>
            <p>Listen carefully and identify the bird by its song!</p>
        </div>

        <div id="loadingSection" class="loading-section">
            <div class="loading-spinner"></div>
            <div class="loading-text">Preparing bird songs...</div>
            <div class="loading-detail">Loading high-quality recordings</div>
        </div>

        <div id="gameContent" style="display: none;">
            <div class="info-box">
                <p><strong>🎵 About the recordings:</strong> This game uses curated bird songs from professional field recordings. Each recording includes attribution and links to the full collection.</p>
            </div>

            <div class="difficulty-selector">
                <label for="difficulty">Select Difficulty:</label>
                <select id="difficulty">
                    <option value="easy">Easy (4 birds)</option>
                    <option value="medium" selected>Medium (6 birds)</option>
                    <option value="hard">Hard (8 birds)</option>
                </select>
            </div>

            <div class="game-stats">
                <div class="stat">
                    <div class="stat-label">Round</div>
                    <div class="stat-value" id="round">1</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Score</div>
                    <div class="stat-value" id="score">0</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Streak</div>
                    <div class="stat-value" id="streak">0</div>
                </div>
            </div>

            <div class="audio-section">
                <p style="margin-bottom: 15px; color: #2d3748; font-size: 1.1em;">🎵 Listen to the bird song</p>
                <button class="play-button" id="playButton">
                    <span id="playIcon">▶</span> <span id="playText">Play Bird Song</span>
                </button>
                <p style="margin-top: 15px; color: #718096; font-size: 0.9em;">Click to hear the mystery bird!</p>
                <div class="attribution" id="attribution"></div>
                <div id="debugLog" class="debug-log" aria-live="polite"></div>
            </div>

            <div class="result-message" id="resultMessage"></div>
            <div class="bird-grid" id="birdGrid"></div>

            <div class="controls">
                <button class="btn btn-secondary" id="replayButton">🔄 Replay Song</button>
                <button class="btn btn-primary" id="nextButton" style="display: none;">Next Round ➜</button>
            </div>

            <div id="gameOverSection" style="display: none;"></div>
        </div>
    </div>

    <script>
        const allBirds = [
            // ... (same bird list as before; omitted here for brevity) ...
        ];

        let gameState = {
            round: 1,
            score: 0,
            streak: 0,
            maxRounds: 10,
            currentBird: null,
            roundBirds: [],
            answered: false,
            difficulty: 'medium',
            currentAudio: null,
            audioCache: {}
        };

        // Debug logging helper
        function formatTime(d = new Date()) {
            return d.toISOString();
        }
        function logDebug(message, obj) {
            const el = document.getElementById('debugLog');
            const time = formatTime();
            const text = `[${time}] ${message}` + (obj ? ` - ${String(obj)}` : '');
            console.log(text, obj);
            if (el) {
                let extra = '';
                if (obj instanceof Error) {
                    extra = '\n' + (obj.stack || obj.message);
                } else if (obj && typeof obj === 'object') {
                    try { extra = '\n' + JSON.stringify(obj, null, 2); } catch (e) { extra = '\n[object]'; }
                }
                el.textContent = `${text}${extra}\n\n` + el.textContent;
            }
        }

        function mediaErrorMessage(err) {
            if (!err) return 'No MediaError';
            const code = err.code;
            switch (code) {
                case 1: return 'MEDIA_ERR_ABORTED (1): fetching process aborted by user';
                case 2: return 'MEDIA_ERR_NETWORK (2): error occurred when downloading';
                case 3: return 'MEDIA_ERR_DECODE (3): error occurred when decoding';
                case 4: return 'MEDIA_ERR_SRC_NOT_SUPPORTED (4): audio not supported or cross-origin blocked';
                default: return `Unknown MediaError code: ${code}`;
            }
        }

        // Prepare an audio URL for playback:
        // 1) Try a CORS fetch -> blob -> objectURL (most robust when allowed)
        // 2) If that fails, try a proxy fallback (configurable)
        // 3) If all fail, return the original URL (may still work depending on browser/server)
        async function prepareAudioUrl(originalUrl) {
            logDebug('prepareAudioUrl: starting for ' + originalUrl);
            // Try direct fetch first
            try {
                logDebug('prepareAudioUrl: attempting fetch (cors) for', originalUrl);
                const resp = await fetch(originalUrl, { mode: 'cors' });
                logDebug('prepareAudioUrl: fetch response', { status: resp.status, type: resp.type, url: resp.url });
                if (resp.ok) {
                    const contentType = resp.headers.get('content-type') || '';
                    logDebug('prepareAudioUrl: content-type: ' + contentType);
                    // If it's probably audio, make blob URL
                    if (contentType.includes('audio') || contentType.includes('mpeg') || contentType.includes('octet-stream') ) {
                        const blob = await resp.blob();
                        const objUrl = URL.createObjectURL(blob);
                        logDebug('prepareAudioUrl: created objectURL from fetch', objUrl);
                        return { url: objUrl, source: 'fetch-blob' };
                    } else {
                        // Even if content-type is not audio, try returning object URL in case server misreports
                        const blob = await resp.blob();
                        const objUrl = URL.createObjectURL(blob);
                        logDebug('prepareAudioUrl: created objectURL despite unexpected content-type', { objUrl, contentType });
                        return { url: objUrl, source: 'fetch-blob' };
                    }
                } else {
                    logDebug(`prepareAudioUrl: fetch returned non-ok status ${resp.status} ${resp.statusText}`);
                }
            } catch (err) {
                logDebug('prepareAudioUrl: fetch failed (likely CORS or network error)', err);
            }

            // Proxy fallback (temporary workaround) - change proxyPrefix if you have a self-hosted proxy
            const proxyPrefix = 'https://cors.bridged.cc/'; // not guaranteed/reliable; replace with your proxy
            try {
                const proxied = proxyPrefix + originalUrl;
                logDebug('prepareAudioUrl: attempting proxy fetch for', proxied);
                const resp2 = await fetch(proxied);
                logDebug('prepareAudioUrl: proxy fetch response', { status: resp2.status, type: resp2.type, url: resp2.url });
                if (resp2.ok) {
                    const contentType2 = resp2.headers.get('content-type') || '';
                    logDebug('prepareAudioUrl: proxy content-type: ' + contentType2);
                    const blob2 = await resp2.blob();
                    const objUrl2 = URL.createObjectURL(blob2);
                    logDebug('prepareAudioUrl: created objectURL from proxy fetch', objUrl2);
                    return { url: objUrl2, source: 'proxy-blob' };
                } else {
                    logDebug('prepareAudioUrl: proxy fetch returned non-ok', { status: resp2.status, statusText: resp2.statusText });
                }
            } catch (err2) {
                logDebug('prepareAudioUrl: proxy fetch failed', err2);
            }

            // Last resort: return original URL (audio element might be able to play it despite prior errors)
            logDebug('prepareAudioUrl: falling back to original URL (may fail): ' + originalUrl);
            return { url: originalUrl, source: 'original' };
        }

        // Create Audio object and attach listeners
        function createAudioElement(url) {
            const audio = new Audio();
            audio.preload = 'auto';
            audio.src = url;

            audio.addEventListener('error', (ev) => {
                const e = ev?.target?.error;
                const msg = mediaErrorMessage(e);
                logDebug(`audio.error event for src=${audio.src}: ${msg}`, e || ev);
            });
            audio.addEventListener('loadeddata', () => logDebug(`loadeddata for src=${audio.src}, readyState=${audio.readyState}, networkState=${audio.networkState}`));
            audio.addEventListener('canplaythrough', () => logDebug(`canplaythrough for src=${audio.src}, readyState=${audio.readyState}, networkState=${audio.networkState}`));
            audio.addEventListener('stalled', () => logDebug(`stalled event for src=${audio.src}`));
            audio.addEventListener('suspend', () => logDebug(`suspend event for src=${audio.src}`));
            audio.addEventListener('waiting', () => logDebug(`waiting event for src=${audio.src}`));

            return audio;
        }

        // Preload audio: use prepareAudioUrl to obtain playable url (blob or original)
        async function preloadAudio() {
            const loadingSection = document.getElementById('loadingSection');
            const loadingDetail = loadingSection.querySelector('.loading-detail');

            let loaded = 0;
            const total = allBirds.length;

            for (const bird of allBirds) {
                try {
                    loadingDetail.textContent = `Loading ${bird.name} (${loaded + 1}/${total})...`;
                    logDebug('preloadAudio: preparing ' + bird.name + ' -> ' + bird.audioUrl);

                    const prepared = await prepareAudioUrl(bird.audioUrl);
                    logDebug('preloadAudio: prepareAudioUrl returned', prepared);

                    const audioElement = createAudioElement(prepared.url);

                    // Wait a short time for loadeddata/canplaythrough but do not block too long
                    await new Promise((resolve, reject) => {
                        let settled = false;
                        const onSuccess = () => { if (settled) return; settled = true; cleanup(); resolve(); };
                        const onError = (ev) => { if (settled) return; settled = true; cleanup(); reject(ev || new Error('audio error')); };
                        const cleanup = () => {
                            audioElement.removeEventListener('canplaythrough', onSuccess);
                            audioElement.removeEventListener('loadeddata', onSuccess);
                            audioElement.removeEventListener('error', onError);
                        };
                        audioElement.addEventListener('canplaythrough', onSuccess, { once: true });
                        audioElement.addEventListener('loadeddata', onSuccess, { once: true });
                        audioElement.addEventListener('error', onError, { once: true });
                        try { audioElement.load(); } catch (e) { logDebug('audio.load() threw in preload', e); }
                        setTimeout(() => {
                            if (settled) return;
                            logDebug('preloadAudio: timeout waiting for loadeddata/canplaythrough for ' + bird.name + ', continuing (audio may still work on demand).');
                            settled = true;
                            cleanup();
                            resolve();
                        }, 5000);
                    });

                    gameState.audioCache[bird.name] = audioElement;
                    logDebug('preloadAudio: cached audio element for ' + bird.name + ' (src=' + audioElement.src + ')');
                    loaded++;
                } catch (err) {
                    logDebug('preloadAudio: could not preload audio for ' + bird.name, err);
                    loaded++;
                }
            }

            loadingSection.style.display = 'none';
            document.getElementById('gameContent').style.display = 'block';
            logDebug('preloadAudio: complete, showing game UI');
            initGame();
        }

        async function playBirdSong() {
            const playButton = document.getElementById('playButton');
            const playIcon = document.getElementById('playIcon');
            const playText = document.getElementById('playText');

            logDebug('playBirdSong called', { currentBird: gameState.currentBird ? gameState.currentBird.name : null });

            if (gameState.currentAudio && !gameState.currentAudio.paused) {
                try {
                    gameState.currentAudio.pause();
                    gameState.currentAudio.currentTime = 0;
                    logDebug('Paused current audio and reset time');
                } catch (e) {
                    logDebug('Error pausing current audio', e);
                }
                playButton.classList.remove('playing');
                playIcon.textContent = '▶';
                playText.textContent = 'Play Bird Song';
                return;
            }

            if (!gameState.currentBird) {
                logDebug('No current bird selected to play');
                return;
            }

            let cached = gameState.audioCache[gameState.currentBird.name];
            logDebug('Audio cache lookup', { bird: gameState.currentBird.name, cached: !!cached });

            if (!cached) {
                // Try prepareAudioUrl here too (on-demand)
                try {
                    const prepared = await prepareAudioUrl(gameState.currentBird.audioUrl);
                    logDebug('playBirdSong: prepareAudioUrl (on-demand) returned', prepared);
                    cached = createAudioElement(prepared.url);
                    gameState.audioCache[gameState.currentBird.name] = cached;
                } catch (err) {
                    logDebug('playBirdSong: prepareAudioUrl failed on-demand', err);
                }
            }

            if (!cached) {
                // Fallback: try using original URL directly as audio.src (last resort)
                logDebug('playBirdSong: no cached audio available; creating audio with original URL', gameState.currentBird.audioUrl);
                cached = createAudioElement(gameState.currentBird.audioUrl);
                gameState.audioCache[gameState.currentBird.name] = cached;
            }

            gameState.currentAudio = cached;

            try {
                cached.currentTime = 0;
            } catch (e) {
                logDebug('Setting currentTime failed (may not be seekable yet)', e);
            }

            logDebug('Attempting audio.play()', { src: cached.src, readyState: cached.readyState, networkState: cached.networkState });

            try {
                const playResult = cached.play();
                if (playResult && typeof playResult.then === 'function') {
                    playResult.then(() => {
                        logDebug('Playback started successfully');
                        playButton.classList.add('playing');
                        playIcon.textContent = '⏸';
                        playText.textContent = 'Pause';
                    }).catch((err) => {
                        logDebug('Playback promise rejected', err);
                        alert('Playback failed. Check the debug panel for details. Consider hosting the audio locally if remote files are blocked by CORS.');
                        document.getElementById('attribution').textContent = 'Playback failed. See debug log for details.';
                    });
                } else {
                    playButton.classList.add('playing');
                    playIcon.textContent = '⏸';
                    playText.textContent = 'Pause';
                    logDebug('audio.play() did not return a promise, assuming success');
                }
            } catch (err) {
                logDebug('audio.play() threw an exception', err);
                alert('Playback failed. Check the debug panel for details.');
                document.getElementById('attribution').textContent = 'Playback exception. See debug log for details.';
            }

            const bird = gameState.currentBird;
            document.getElementById('attribution').innerHTML = `Recording by ${bird.recordist} | <a href="https://xeno-canto.org/${bird.xcId}" target="_blank">View on Xeno-canto (XC${bird.xcId})</a>`;

            cached.onended = () => {
                logDebug('audio ended event for src=' + cached.src);
                playButton.classList.remove('playing');
                playIcon.textContent = '▶';
                playText.textContent = 'Play Bird Song';
            };
        }

        function startNewRound() {
            gameState.answered = false;
            if (gameState.currentAudio) {
                try { gameState.currentAudio.pause(); gameState.currentAudio.currentTime = 0; } catch (e) { logDebug('Error stopping audio', e); }
            }
            const playButton = document.getElementById('playButton');
            playButton.classList.remove('playing');
            document.getElementById('playIcon').textContent = '▶';
            document.getElementById('playText').textContent = 'Play Bird Song';
            const numBirds = gameState.difficulty === 'easy' ? 4 : gameState.difficulty === 'medium' ? 6 : 8;
            const shuffled = [...allBirds].sort(() => Math.random() - 0.5);
            gameState.roundBirds = shuffled.slice(0, numBirds);
            gameState.currentBird = gameState.roundBirds[Math.floor(Math.random() * numBirds)];
            logDebug('Started new round', { round: gameState.round, currentBird: gameState.currentBird.name });
            updateStats();
            renderBirdCards();
            document.getElementById('resultMessage').classList.remove('show');
            document.getElementById('nextButton').style.display = 'none';
            document.getElementById('playButton').disabled = false;
            document.getElementById('replayButton').disabled = false;
            document.getElementById('attribution').innerHTML = '';
            document.getElementById('debugLog').textContent = '';
        }

        function updateStats() {
            document.getElementById('round').textContent = gameState.round;
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('streak').textContent = gameState.streak;
        }

        function renderBirdCards() {
            const grid = document.getElementById('birdGrid');
            grid.innerHTML = '';
            gameState.roundBirds.forEach(bird => {
                const card = document.createElement('div');
                card.className = 'bird-card';
                card.innerHTML = `<div class="bird-name">${bird.name}</div><div class="bird-scientific">${bird.scientific}</div><div class="bird-info">${bird.info}</div>`;
                card.onclick = () => selectBird(bird, card);
                grid.appendChild(card);
            });
        }

        function selectBird(bird, cardElement) {
            if (gameState.answered) return;
            gameState.answered = true;
            const isCorrect = bird === gameState.currentBird;
            if (gameState.currentAudio) { try { gameState.currentAudio.pause(); } catch (e) { logDebug('Error pausing on select', e); } }
            const playButton = document.getElementById('playButton');
            playButton.classList.remove('playing');
            document.getElementById('playIcon').textContent = '▶';
            document.getElementById('playText').textContent = 'Play Bird Song';
            document.querySelectorAll('.bird-card').forEach(c => c.classList.add('disabled'));
            cardElement.classList.remove('disabled');
            cardElement.classList.add(isCorrect ? 'correct' : 'incorrect');
            if (!isCorrect) {
                document.querySelectorAll('.bird-card').forEach(c => {
                    const birdName = c.querySelector('.bird-name').textContent;
                    if (birdName === gameState.currentBird.name) {
                        c.classList.remove('disabled');
                        c.classList.add('correct');
                    }
                });
            }
            const resultMsg = document.getElementById('resultMessage');
            if (isCorrect) {
                gameState.score += 10 + (gameState.streak * 2);
                gameState.streak++;
                resultMsg.textContent = `🎉 Correct! That was a ${bird.name}! +${10 + ((gameState.streak - 1) * 2)} points`;
                resultMsg.className = 'result-message show correct';
            } else {
                gameState.streak = 0;
                resultMsg.textContent = `❌ Not quite. That was a ${gameState.currentBird.name}.`;
                resultMsg.className = 'result-message show incorrect';
            }
            logDebug('Selection made', { selected: bird.name, correct: isCorrect, target: gameState.currentBird.name });
            updateStats();
            if (gameState.round >= gameState.maxRounds) {
                setTimeout(endGame, 2000);
            } else {
                document.getElementById('nextButton').style.display = 'inline-block';
            }
            document.getElementById('playButton').disabled = true;
            document.getElementById('replayButton').disabled = true;
        }

        function endGame() {
            const gameOverSection = document.getElementById('gameOverSection');
            const accuracy = Math.round((gameState.score / (gameState.maxRounds * 10)) * 100);
            gameOverSection.innerHTML = `<div class="game-over"><h2>🏆 Game Complete!</h2><div class="final-score">${gameState.score}</div><p style="font-size: 1.2em; color: #2d3748; margin-bottom: 20px;">You identified birds with ${accuracy}% accuracy!</p><p style="font-size: 0.9em; color: #718096; margin-bottom: 20px;">Recordings courtesy of <a href="https://xeno-canto.org" target="_blank">Xeno-canto.org</a></p><button class="btn btn-primary" onclick="initGame()">🔄 Play Again</button></div>`;
            gameOverSection.style.display = 'block';
            logDebug('Game ended', { score: gameState.score, accuracy });
        }

        document.getElementById('playButton').addEventListener('click', playBirdSong);
        document.getElementById('replayButton').addEventListener('click', playBirdSong);
        document.getElementById('nextButton').addEventListener('click', () => { gameState.round++; startNewRound(); });
        document.getElementById('difficulty').addEventListener('change', () => { if (confirm('Changing difficulty will restart the game. Continue?')) initGame(); });

        logDebug('Page load: starting audio preload');
        preloadAudio();
    </script>
</body>
</html>
